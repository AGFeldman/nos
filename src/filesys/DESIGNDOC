                     +-------------------------+
                     |          CS 124         |
                     | PROJECT 6: FILE SYSTEMS |
                     |     DESIGN DOCUMENT     |
                     +-------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Julie Kew <julie.kew@gmail.com>
Aaron Feldman <feldmando@gmail.com>

>> Specify how many late tokens you are using on this assignment:  
0

>> What is the Git repository and commit hash for your submission?

   Repository URL: https://github.com/AGFeldman/nos 
   commit On branch "filesys": 34c0e18e7548a764af64a30a6615bcc8a7f88ffc 

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

Incomplete subdirectories work is on a "subdirectories" branch:
https://github.com/AGFeldman/nos/tree/subdirectories/src/filesys

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course instructors.

             INDEXED AND EXTENSIBLE FILES
             ============================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

// Number of blocks directly accessible from an on-disk inode
#define NUM_DIRECT 123
// Number of blocks indirectly accessible from an on-disk inode
#define NUM_INDIRECT 1
// Number of blocks doubly-indirectly accessible from an on-disk inode
#define NUM_DINDIRECT 1

/*! On-disk inode.
    Must be exactly BLOCK_SECTOR_SIZE bytes long. */
struct inode_disk {
    block_sector_t start;               /*!< First data sector. */
    off_t length;                       /*!< File size in bytes. */
    unsigned magic;                     /*!< Magic number. */
    // Array of sectors.
    // For simplicity, we should have blocks[0] == start.
    block_sector_t blocks[NUM_DIRECT + NUM_INDIRECT + NUM_DINDIRECT];
};

/*! In-memory inode. */
struct inode {
    struct list_elem elem;              /*!< Element in inode list. */
    // This is how we will access the inode's content
    block_sector_t sector;              /*!< Sector number of disk location. */
    int open_cnt;                       /*!< Number of openers. */
    bool removed;                       /*!< True if deleted, false otherwise. */
    int deny_write_cnt;                 /*!< 0: writes ok, >0: deny writes. */
    // Length of the inode's data, in bytes
    off_t length;
    // Used to enforce the restriction that at most one process may extend
    // a file at one time.
    struct lock extend_lock;
};


// A structure for iterating through the blocks indexed by an inode.
struct inode_iter {
    struct inode_disk * idisk;
    struct inode * inode;
    block_sector_t * bottom;
    int bottom_offset;
    block_sector_t * first_level;
    int first_level_offset;
    block_sector_t * second_level;
    int second_level_offset;
    block_sector_t sector_num;
    block_sector_t value;
    block_sector_t num_allocated_sectors;
    block_sector_t max_num_allocated_sectors;
};


>> A2: What is the maximum size of a file supported by your inode
>> structure?  Show your work.

Let's count the sectors.
We have 123 direct blocks, so that's 123 sectors.
We have 1 indirect block, and each one can address 128 sectors. So that's
another 1 * 128 sectors.
We have 1 doubly-indirect block, so that's another 1 * 128 * 128 sectors.
For a grand total of 123 + 1 * 128 + 1 * 128^2 = 16635 sectors.
Each sector is 512 bytes, so this a max file size of 8388859 bytes,
or about 8.00024 MiB.

---- SYNCHRONIZATION ----

>> A3: Explain how your code avoids a race if two processes attempt to
>> extend a file at the same time.

Each `struct inode` has a mutex lock called `extend_lock` that must be held
while extending a file.

>> A4: Suppose processes A and B both have file F open, both
>> positioned at end-of-file.  If A reads and B writes F at the same
>> time, A may read all, part, or none of what B writes.  However, A
>> may not read data other than what B writes, e.g. if B writes
>> nonzero data, A is not allowed to see all zeros.  Explain how your
>> code avoids this race.

Our code does have an intermediate step where B extends the file with all 
zeros, even though B is not writing zeros. However, the length of the file
is not marked as extended until B is finished with it, so A won't be able to
read past the end of the original file until B has finished writing its data.

>> A5: Explain how your synchronization design provides "fairness".
>> File access is "fair" if readers cannot indefinitely block writers
>> or vice versa.  That is, many processes reading from a file cannot
>> prevent forever another process from writing the file, and many
>> processes writing to a file cannot prevent another process forever
>> from reading the file.

There are very few restrictions on what may happen simultaneously. Only one
process may extend a file at one time, but that is the only file-level 
restriction. There are block-level restrictions enforced that can be enforced
by a read-write lock in the buffer cache. (TODO(agf): At time of writing, not
sure how completely these are enforced.) In this case, fairness depends on the
fairness of the read-write lock. Our RW lock tries to be fair: If the number
of readers hits zero, it signals to waiting writers before giving up the mutex
lock, and when it releases the write lock, it broadcasts to waiting readers
before signaling to other writers. However, it is still possible that a steady
stream of readers could prevent a write from ever occurring.

---- RATIONALE ----

>> A6: Is your inode structure a multilevel index?  If so, why did you
>> choose this particular combination of direct, indirect, and doubly
>> indirect blocks?  If not, why did you choose an alternative inode
>> structure, and what advantages and disadvantages does your
>> structure have, compared to a multilevel index?

Yes, we use a multi-level index structure. There are 123 direct blocks.
There is one indirect block, which links to 128 blocks. And, there is one
doubly indirect block, which links to 128 blocks, each of which links to 
another 128 blocks. This seemed like the simplest structure that could allow
us to index 8MiB files. One could imagine a structure where not all children
of the doubly indirect block go equally deep. This might be slightly more
space efficient, but did not seem close to being worth the added implementation
complexity.

                SUBDIRECTORIES
                ==============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct dir_entry {
    block_sector_t inode_sector;        /*!< Sector number of header. */
    block_sector_t parent_sector;
    char name[NAME_MAX + 1];            /*!< Null terminated file name. */
    bool in_use;                        /*!< In use or free? */
    bool isdir;
};
Added the parent's sector for moving up a directory level and the isdir bool
for distinguishing files from directories when following a filepath.

Added to thread struct:
    /* Current directory */
    struct dir *working_dir;

---- ALGORITHMS ----

>> B2: Describe your code for traversing a user-specified path.  How
>> do traversals of absolute and relative paths differ?

We use strtok_r to get one directory/file at a time, open it in front of us,
and close it once we've opened the next one. Traversals of absolute and 
relative paths simply begin from different directories (so the function
file_from_path() is given a different argument).

---- SYNCHRONIZATION ----

>> B4: How do you prevent races on directory entries?  For example,
>> only one of two simultaneous attempts to remove a single file
>> should succeed, as should only one of two simultaneous attempts to
>> create a file with the same name, and so on.

Implementation is incomplete

>> B5: Does your implementation allow a directory to be removed if it
>> is open by a process or if it is in use as a process's current
>> working directory?  If so, what happens to that process's future
>> file system operations?  If not, how do you prevent it?

Implementation is incomplete

---- RATIONALE ----

>> B6: Explain why you chose to represent the current directory of a
>> process the way you did.

The current directory is represented as a struct dir *, which means that the
current dir is always open. This makes sense because the current directory
is often being searched or written to.

                 BUFFER CACHE
                 ============

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

#define NUM_CACHE_BLOCKS 64

// Buffer cache block
struct bc_block {
    // Whether we have filled the block yet
    bool occupied;
    // Whether the block has been accessed since being loaded
    bool accessed;
    // Whether the block has been written to since being loaded
    bool dirty;
    // The disk sector that the block came from
    block_sector_t block_num;
    // A pointer to the 512 in-memory bytes that mirror the bytes on disk
    // (might be dirty)
    char * data;
    // For protecting cache block entries
    struct rwlock rwlock;
};
Stores information about each block in the cache. 

// Buffer cache, an array of 64 bc_blocks,
// each of which holds one block (512 bytes) of memory
struct bc_block * bc;

// For clock eviction algorithm
struct bc_block * hand;
Iterates through the array bc, clearing accessed bits, until it finds an unaccessed block.

---- ALGORITHMS ----

>> C2: Describe how your cache replacement algorithm chooses a cache
>> block to evict.
We use a simple clock algorithm. If the entry under the hand is marked as
"accessed", then we clear the "accessed" attribute and move on to the next
entry. We evict the first entry we find with a clear "accessed" attribute.

>> C3: Describe your implementation of write-behind.

At the end of initializing the buffer cache, we start a background 
"write_behind" thread. This thread repeatedly sleeps for 30 seconds (using
timer_msleep()), then flushes the buffer cache to disk. We chose 30 seconds
because I got the impression that that is the default time for Linux, though
I didn't look it up.

>> C4: Describe your implementation of read-ahead.

We have outline code that starts another thread in the background. This code
would be called at the beginning of a block read. However, that is not 
implemented.

---- SYNCHRONIZATION ----

>> C5: When one process is actively reading or writing data in a
>> buffer cache block, how are other processes prevented from evicting
>> that block?

We can have a read-write lock for each buffer cache entry. Read-acquire
or write-acquire is performed when reading from or writing to a cache entry.
Write-acquire is required before evicting the block.
TODO(agf): Implementation may be incomplete

>> C6: During the eviction of a block from the cache, how are other
>> processes prevented from attempting to access the block?

The write lock is held on the block in question. 
TODO(agf): Implementation may be incomplete.

---- RATIONALE ----

>> C7: Describe a file workload likely to benefit from buffer caching,
>> and workloads likely to benefit from read-ahead and write-behind.

A workload that accesses some blocks repeatedly and frequently would benefit
from buffer caching. For example, a process might use part of a file to store
a counter, which it updates frequently. Since this would hit the same block
frequently, it would benefit from buffer caching.

A workload that performs a lot of sequential access would benefit from 
read-ahead. One example is playing video or audio.

Write-behind mostly protects against crashes being *too* bad -- you won't lose
*too* much data. But you could lose some data. For this reason, workloads that
depend on write-behind should be tolerant if some small amount of data is
lost. One such workload would be gathering weather data.

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the feedback survey on the course
website.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

It is very hard to test this assignment in small chunks.

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students in future quarters?

>> Any other comments?

